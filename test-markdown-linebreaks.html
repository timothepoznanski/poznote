<!DOCTYPE html>
<html>
<head>
    <title>Test Markdown Line Breaks</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-container { display: flex; gap: 20px; margin-bottom: 20px; }
        .editor, .preview { 
            border: 1px solid #ccc; 
            width: 45%; 
            min-height: 200px; 
            padding: 10px; 
        }
        .editor { 
            font-family: monospace; 
            white-space: pre-wrap; 
            background: #f9f9f9; 
        }
        .preview { background: white; }
        .test-input { font-family: monospace; white-space: pre; background: #f0f0f0; padding: 10px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Test des sauts de ligne Markdown</h1>
    
    <div class="test-container">
        <div>
            <h3>Input Markdown</h3>
            <div class="test-input" id="testInput">Ligne 1
Ligne 2 (saut de ligne simple)

Nouveau paragraphe après ligne vide

Ligne avec 2 espaces à la fin  
Nouvelle ligne après 2 espaces

Ligne courte.
Nouvelle phrase.</div>
        </div>
        <div>
            <h3>Rendu HTML</h3>
            <div class="preview" id="preview"></div>
        </div>
    </div>

    <script>
        // Copy the functions from markdown-handler.js
        function normalizeContentEditableText(element) {
            var content = element.innerText || element.textContent || '';
            content = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            return content;
        }

        function parseMarkdown(text) {
            if (!text) return '';
            
            let protectedElements = [];
            let protectedIndex = 0;
            
            // Protect images first ![alt](url "title")
            text = text.replace(/!\[([^\]]*)\]\(([^\s\)]+)(?:\s+"([^"]+)")?\)/g, function(match, alt, url, title) {
                let placeholder = '\x00PIMG' + protectedIndex + '\x00';
                let imgTag;
                if (title) {
                    imgTag = '<img src="' + url + '" alt="' + alt + '" title="' + title + '">';
                } else {
                    imgTag = '<img src="' + url + '" alt="' + alt + '">';
                }
                protectedElements[protectedIndex] = imgTag;
                protectedIndex++;
                return placeholder;
            });
            
            // Protect links [text](url "title")
            text = text.replace(/\[([^\]]+)\]\(([^\s\)]+)(?:\s+"([^"]+)")?\)/g, function(match, linkText, url, title) {
                let placeholder = '\x00PLNK' + protectedIndex + '\x00';
                let linkTag;
                if (title) {
                    linkTag = '<a href="' + url + '" title="' + title + '" target="_blank" rel="noopener">' + linkText + '</a>';
                } else {
                    linkTag = '<a href="' + url + '" target="_blank" rel="noopener">' + linkText + '</a>';
                }
                protectedElements[protectedIndex] = linkTag;
                protectedIndex++;
                return placeholder;
            });
            
            // Now escape HTML to prevent XSS
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Helper function to apply inline styles (bold, italic, code, etc.)
            function applyInlineStyles(text) {
                // Inline code (must be first to protect code content from other replacements)
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Bold and italic
                text = text.replace(/\*\*\*([^\*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
                text = text.replace(/___([^_]+)___/g, '<strong><em>$1</em></strong>');
                text = text.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/__([^_]+)__/g, '<strong>$1</strong>');
                text = text.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
                text = text.replace(/_([^_]+)_/g, '<em>$1</em>');
                
                // Strikethrough
                text = text.replace(/~~([^~]+)~~/g, '<del>$1</del>');
                
                // Restore protected elements (images and links)
                text = text.replace(/\x00P(IMG|LNK)(\d+)\x00/g, function(match, type, index) {
                    return protectedElements[parseInt(index)] || match;
                });
                
                return text;
            }
            
            // Process line by line for block-level elements
            let lines = html.split('\n');
            let result = [];
            let currentParagraph = [];
            
            function flushParagraph() {
                if (currentParagraph.length > 0) {
                    // Process line breaks according to Markdown rules:
                    // - Lines ending with 2+ spaces become <br>
                    // - Other lines are joined with spaces, unless they're short (likely intentional breaks)
                    let processedLines = [];
                    for (let i = 0; i < currentParagraph.length; i++) {
                        let line = currentParagraph[i];
                        if (i < currentParagraph.length - 1) {
                            // Check if line ends with 2+ spaces (hard line break)
                            if (line.match(/\s{2,}$/)) {
                                processedLines.push(line.replace(/\s{2,}$/, '') + '<br>');
                            } else {
                                // For short lines or if next line starts a new sentence, add line break
                                let nextLine = currentParagraph[i + 1];
                                if (line.length < 80 && (nextLine.match(/^[A-Z]/) || line.match(/[.!?:]$/))) {
                                    processedLines.push(line + '<br>');
                                } else {
                                    // Soft line break - join with next line using space
                                    processedLines.push(line + ' ');
                                }
                            }
                        } else {
                            // Last line
                            processedLines.push(line);
                        }
                    }
                    let para = processedLines.join('').replace(/\s+<br>/g, '<br>').replace(/\s+$/, '');
                    para = applyInlineStyles(para);
                    result.push('<p>' + para + '</p>');
                    currentParagraph = [];
                }
            }
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                
                // Empty line - paragraph separator
                if (line.trim() === '') {
                    flushParagraph();
                    continue;
                }
                
                // Headers (simplified for test)
                if (line.match(/^#/)) {
                    flushParagraph();
                    result.push('<h1>' + line.replace(/^#+\s*/, '') + '</h1>');
                    continue;
                }
                
                // Regular text - add to current paragraph
                currentParagraph.push(line);
            }
            
            // Flush any remaining paragraph
            flushParagraph();
            
            return result.join('\n');
        }

        // Test the function
        document.addEventListener('DOMContentLoaded', function() {
            const input = document.getElementById('testInput');
            const preview = document.getElementById('preview');
            
            const testText = input.textContent;
            const renderedHtml = parseMarkdown(testText);
            
            preview.innerHTML = renderedHtml;
            
            console.log('Input:', testText);
            console.log('Output:', renderedHtml);
        });
    </script>
</body>
</html>